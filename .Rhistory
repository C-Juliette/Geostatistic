})
######################### REGULAR TESTS #######################
test_that("Regular test - Z a matrix", {
# arrange
Z <- matrix(1:4, nrow = 2)
Var1 <- c(1, 2, 1, 2)
Var1 <- as.data.frame(Var1)
Var2 <- c(1, 1, 2, 2)
Var2 <- as.data.frame(Var2)
value <- c(1, 2, 3, 4)
value <- as.data.frame(value)
# act
actual <- long_shaped_matrix(Z)
# assert
expected <- tibble::tibble(cbind(Var1, Var2, value))
#expected$Var1 <- as.integer(expected$Var1)
#expected$Var2 <- as.integer(expected$Var2)
#expected$value <- as.integer(expected$value)
expect_equal(actual, expected)
})
test_that("Regular test - Z a dataframe", {
# arrange
Z <- as.data.frame(matrix(1:4, nrow = 2))
Var1 <- c(1, 2, 1, 2)
Var1 <- as.data.frame(Var1)
Var2 <- c(1, 1, 2, 2)
Var2 <- as.data.frame(Var2)
value <- c(1, 2, 3, 4)
value <- as.data.frame(value)
# act
actual <- long_shaped_matrix(Z)
# assert
expected <- tibble::tibble(cbind(Var1, Var2, value))
#expected$Var1 <- as.integer(expected$Var1)
#expected$Var2 <- as.integer(expected$Var2)
#expected$value <- as.integer(expected$value)
expect_equal(actual, expected)
})
test_that("Regular test - Z a number", {
# arrange
Z <- 1
Var1 <- c(1)
Var1 <- as.data.frame(Var1)
Var2 <- c(1)
Var2 <- as.data.frame(Var2)
value <- c(1)
value <- as.data.frame(value)
# act
actual <- long_shaped_matrix(Z)
# assert
expected <- tibble::tibble(cbind(Var1, Var2, value))
expect_equal(actual, expected)
})
#' Long shaped matrix
#'
#' @param Z a matrix/dataframe/vector
#'
#' @return a dataframe : first column is x coordinates, second column is y coordinate, third column is the value
#' @export
#'
#' @examples
#' Z <- matrix(1:25, nrow = 5)
#' long_shaped_matrix(Z)
long_shaped_matrix <- function(Z){
if (!is.vector(Z) & !is.matrix(Z) & !is.data.frame(Z)){stop("Z must be a vector/matrix/dataframe/number/string")}
Z <- as.data.frame(Z)
nrows <- dim(Z)[1]
ncols <- dim(Z)[2]
Z <- Z |> as.data.frame() |> setNames(1:ncols) |> tidyr::gather() |> setNames(c("Var2","value"))
Z$Var1 <- seq(1:nrows)
Z$Var2 <- as.integer(Z$Var2)
Z <- Z[, c("Var1", "Var2", "value")] |> tibble::tibble()
return (Z)
}
test_that("Regular test - Z a number", {
# arrange
Z <- 1
Var1 <- c(1)
Var1 <- as.data.frame(Var1)
Var2 <- c(1)
Var2 <- as.data.frame(Var2)
value <- c(1)
value <- as.data.frame(value)
# act
actual <- long_shaped_matrix(Z)
# assert
expected <- tibble::tibble(cbind(Var1, Var2, value))
expect_equal(actual, expected)
})
test_that("Regular test - Z a vector", {
# arrange
Z <- c(1:4)
Var1 <- c(1, 2, 3, 4)
Var1 <- as.data.frame(Var1)
Var2 <- c(1, 1, 1, 1)
Var2 <- as.data.frame(Var2)
value <- c(1, 2, 3, 4)
value <- as.data.frame(value)
# act
actual <- long_shaped_matrix(Z)
# assert
expected <- tibble::tibble(cbind(Var1, Var2, value))
#expected$Var1 <- as.integer(expected$Var1)
#expected$Var2 <- as.integer(expected$Var2)
#expected$value <- as.integer(expected$value)
expect_equal(actual, expected)
})
test_that("Regular test - Z a number", {
# arrange
Z <- c("a")
Var1 <- c(1)
Var1 <- as.data.frame(Var1)
Var2 <- c(1)
Var2 <- as.data.frame(Var2)
value <- c("a")
value <- as.data.frame(value)
# act
actual <- long_shaped_matrix(Z)
# assert
expected <- tibble::tibble(cbind(Var1, Var2, value))
expect_equal(actual, expected)
})
######################## ANOMALY TESTS #####################
test_that("Anomaly test - error when the parametre is not a matrix/dataframe/vector/number", {
# arrange
f <- function(){paste("I am a function")}
# act & assert
expect_error(long_shaped_matrix(f), "^Z must be a vector/matrix/dataframe/number/string$")
})
test_that("Regular test - Z a number", {
# arrange
Z <- c("a")
Var1 <- c(1)
Var1 <- as.data.frame(Var1)
Var2 <- c(1)
Var2 <- as.data.frame(Var2)
value <- c("a")
value <- as.data.frame(value)
# act
actual <- long_shaped_matrix(Z)
# assert
expected <- tibble::tibble(cbind(Var1, Var2, value))
expect_equal(actual, expected)
})
test_that("Regular test - Z a number", {
# arrange
Z <- "a"
Var1 <- c(1)
Var1 <- as.data.frame(Var1)
Var2 <- c(1)
Var2 <- as.data.frame(Var2)
value <- c("a")
value <- as.data.frame(value)
# act
actual <- long_shaped_matrix(Z)
# assert
expected <- tibble::tibble(cbind(Var1, Var2, value))
expect_equal(actual, expected)
})
# arrange
f <- function(){paste("I am a function")}
c(f)
c("dadzad", 3)
c("dadzad", as.numeric(3))
#' Long shaped matrix
#'
#' @param Z a matrix/dataframe/vector
#'
#' @return a dataframe : first column is x coordinates, second column is y coordinate, third column is the value
#' @export
#'
#' @examples
#' Z <- matrix(1:25, nrow = 5)
#' long_shaped_matrix(Z)
long_shaped_matrix <- function(Z){
if (!is.vector(Z) & !is.matrix(Z) & !is.data.frame(Z)){stop("Z must be a vector/matrix/dataframe")}
Z <- as.data.frame(Z)
nrows <- dim(Z)[1]
ncols <- dim(Z)[2]
Z <- Z |> as.data.frame() |> setNames(1:ncols) |> tidyr::gather() |> setNames(c("Var2","value"))
Z$Var1 <- seq(1:nrows)
Z$Var2 <- as.integer(Z$Var2)
Z <- Z[, c("Var1", "Var2", "value")] |> tibble::tibble()
return (Z)
}
#' Create a new map/matrix by doing a moving average on a matrix
#'
#' @param Z matrix/dataframe
#' @param r integer : the radius of the window of the moving average. Ex : r = 1 implies a window of 3*3
#'
#' @return matrix (side effects imply a smaller matrix than the Z matrix passed in parametre)
#' @export
#'
#' @examples
#' moving_average(matrix(rnorm(10*10, 0,1), nrow = 10), r=2)
moving_average <- function(Z, r){
if (!isInteger(r)){stop("r must be an integer")}
if (r < 0 ){stop("r must be >= 0")}
if (!is.numeric(Z)){stop("Z must be a matrix/dataframe of numbers")}
Z <- as.matrix(Z)
if ( 2*r+1 > dim(Z)[1] | 2*r+1 > dim(Z)[2]){stop("The grid must be larger than the window. Decrease r or increase the grid size")}
nrowsZ <- dim(Z)[1]
ncolsZ <- dim(Z)[2]
nrowsY <- nrowsZ - 2*r
ncolsY <- ncolsZ - 2*r
Y <- matrix(data = rep(0, nrowsY*ncolsY), nrow = nrowsY)
for(i in (r+1):(nrowsZ-r)){
for(j in (r+1):(ncolsZ-r)){
window <- Z[(i-r):(i+r), (j-r):(j+r)]
Y[i-r,j-r] <- mean(window)
}
}
return (tibble::tibble(Y))
}
######################### REGULAR TESTS #######################
test_that("Regular test - unchanged grid when r = 0", {
# arrange
Z <- matrix(rnorm(5*5, 2, 4), nrow = 5)
# act
actual <- moving_average(Z,0)
# assert
expected <- Z
expect_identical(actual, expected)
})
######################### REGULAR TESTS #######################
test_that("Regular test - unchanged grid when r = 0", {
# arrange
Z <- matrix(rnorm(5*5, 2, 4), nrow = 5)
# act
actual <- moving_average(Z,0)
# assert
expected <- Z
expect_equal(actual, expected)
})
######################### REGULAR TESTS #######################
test_that("Regular test - unchanged grid when r = 0", {
# arrange
Z <- matrix(rnorm(5*5, 2, 4), nrow = 5)
# act
actual <- moving_average(Z,0)
# assert
expected <- tibble::tibble(Z)
expect_equal(actual, expected)
})
######################### REGULAR TESTS #######################
test_that("Regular test - unchanged grid when r = 0", {
# arrange
Z <- matrix(rnorm(5*5, 2, 4), nrow = 5)
# act
actual <- moving_average(Z,0)
# assert
expected <- tibble::tibble(as.data.frame(Z))
expect_equal(actual, expected)
})
# arrange
Z <- matrix(rnorm(5*5, 2, 4), nrow = 5)
tibble::tibble(as.data.frame(Z))
moving_average(Z,0)
isInteger <- ttutils::isInteger
#' Create a new map/matrix by doing a moving average on a matrix
#'
#' @param Z matrix/dataframe
#' @param r integer : the radius of the window of the moving average. Ex : r = 1 implies a window of 3*3
#'
#' @return matrix (side effects imply a smaller matrix than the Z matrix passed in parametre)
#' @export
#'
#' @examples
#' moving_average(matrix(rnorm(10*10, 0,1), nrow = 10), r=2)
moving_average <- function(Z, r){
if (!isInteger(r)){stop("r must be an integer")}
if (r < 0 ){stop("r must be >= 0")}
if (!is.numeric(Z)){stop("Z must be a matrix/dataframe of numbers")}
Z <- as.matrix(Z)
if ( 2*r+1 > dim(Z)[1] | 2*r+1 > dim(Z)[2]){stop("The grid must be larger than the window. Decrease r or increase the grid size")}
nrowsZ <- dim(Z)[1]
ncolsZ <- dim(Z)[2]
nrowsY <- nrowsZ - 2*r
ncolsY <- ncolsZ - 2*r
Y <- matrix(data = rep(0, nrowsY*ncolsY), nrow = nrowsY)
for(i in (r+1):(nrowsZ-r)){
for(j in (r+1):(ncolsZ-r)){
window <- Z[(i-r):(i+r), (j-r):(j+r)]
Y[i-r,j-r] <- mean(window)
}
}
return (Y)
}
library(ggplot2)
str_c <- stringr::str_c
#' @param nom_axeX name for X axis
#' @param nom_axeY name for Y axis
#' @param echelle title of scale
#'
#' @return a plot
#' @export
#'
#' @examples
#'
#' plot_matrix(matrix(rbinom(10*10, 1, 0.5), nrow = 10))
plot_matrix <- function(M, r= "", paletteinf = "", palettesup = "", titre = "", nom_axeX = "", nom_axeY = "", echelle = "Echelle"){
titre <- str_c(titre, "   Var = " ,as.character(round(variance(M), 4)),  sep = "")
M <- M |> long_shaped_matrix() # trois colonnes : les i, les j, les valeurs
p <- ggplot(data = M, aes(x = Var1 -0.5, y = Var2 - 0.5) )
if(r != ""){p <- ggplot(M, aes(x = Var1 -0.5+r , y = Var2 -0.5+r, z= value, fill=value))}
p <- p +
geom_tile(aes(fill = value))
if(paletteinf != "" & palettesup != ""){p <- p+scale_fill_viridis_c(option = "B", direction = -1, limits = c(paletteinf, palettesup))}
else{p <- p+scale_fill_viridis_c(option = "B", direction = -1)}
p <- p +
labs(title = titre,
x = nom_axeX,
y = nom_axeY) +
guides(fill = guide_colorbar(title = echelle))+
scale_y_continuous(breaks= scales::pretty_breaks())+
scale_x_continuous(breaks= scales::pretty_breaks())
return(p)
}
plot_matrix(c(1,2,3))
plot_matrix(matrix(1:10, nrow = 5))
#' @param nom_axeX name for X axis
#' @param nom_axeY name for Y axis
#' @param echelle title of scale
#'
#' @return a plot
#' @export
#'
#' @examples
#'
#' plot_matrix(matrix(rbinom(10*10, 1, 0.5), nrow = 10))
plot_matrix <- function(M, r= "", paletteinf = "", palettesup = "", titre = "", nom_axeX = "", nom_axeY = "", echelle = "Echelle"){
if(titre == ""){titre <- str_c("Var = " ,as.character(round(variance(M), 4)),  sep = "")}
else{titre <- str_c(titre, " -  Var = " ,as.character(round(variance(M), 4)),  sep = "")}
M <- M |> long_shaped_matrix() # trois colonnes : les i, les j, les valeurs
p <- ggplot(data = M, aes(x = Var1 -0.5, y = Var2 - 0.5) )
if(r != ""){p <- ggplot(M, aes(x = Var1 -0.5+r , y = Var2 -0.5+r, z= value, fill=value))}
p <- p +
geom_tile(aes(fill = value))
if(paletteinf != "" & palettesup != ""){p <- p+scale_fill_viridis_c(option = "B", direction = -1, limits = c(paletteinf, palettesup))}
else{p <- p+scale_fill_viridis_c(option = "B", direction = -1)}
p <- p +
labs(title = titre,
x = nom_axeX,
y = nom_axeY) +
guides(fill = guide_colorbar(title = echelle))+
scale_y_continuous(breaks= scales::pretty_breaks())+
scale_x_continuous(breaks= scales::pretty_breaks())
return(p)
}
plot_matrix(matrix(1:10, nrow = 5))
plot_matrix(matrix(1:10, nrow = 5), titre = "Ma matrice")
#' @param nom_axeX name for X axis
#' @param nom_axeY name for Y axis
#' @param echelle title of scale
#'
#' @return a plot
#' @export
#'
#' @examples
#'
#' plot_matrix(matrix(rbinom(10*10, 1, 0.5), nrow = 10))
plot_matrix <- function(M, r= "", paletteinf = "", palettesup = "", titre = "", nom_axeX = "", nom_axeY = "", echelle = "Echelle"){
if(titre == ""){titre <- str_c("Var = " ,as.character(round(variance(M), 4)),  sep = "")}
else{titre <- str_c(titre, "  -  Var = " ,as.character(round(variance(M), 4)),  sep = "")}
M <- M |> long_shaped_matrix() # trois colonnes : les i, les j, les valeurs
p <- ggplot(data = M, aes(x = Var1 -0.5, y = Var2 - 0.5) )
if(r != ""){p <- ggplot(M, aes(x = Var1 -0.5+r , y = Var2 -0.5+r, z= value, fill=value))}
p <- p +
geom_tile(aes(fill = value))
if(paletteinf != "" & palettesup != ""){p <- p+scale_fill_viridis_c(option = "B", direction = -1, limits = c(paletteinf, palettesup))}
else{p <- p+scale_fill_viridis_c(option = "B", direction = -1)}
p <- p +
labs(title = titre,
x = nom_axeX,
y = nom_axeY) +
guides(fill = guide_colorbar(title = echelle))+
scale_y_continuous(breaks= scales::pretty_breaks())+
scale_x_continuous(breaks= scales::pretty_breaks())
return(p)
}
plot_matrix(matrix(1:10, nrow = 5), titre = "Ma matrice")
plot_matrix(matrix(1:10, nrow = 5))
plot_matrix(1)
plot_matrix(c(1,2)
)
plot_matrix(c(1,2), c(3,4))
plot_matrix(c(1,2), c(3,4), c(5,6))
plot_matrix(c(1,2))
test_that("Anomaly test - error when M does not contain number", {
# arrange
Z <- "a"
# act & assert
expect_error(moving_average(Z, 2), "^M must be contain numbers$")
})
#' @param nom_axeX name for X axis
#' @param nom_axeY name for Y axis
#' @param echelle title of scale
#'
#' @return a plot
#' @export
#'
#' @examples
#'
#' plot_matrix(matrix(rbinom(10*10, 1, 0.5), nrow = 10))
plot_matrix <- function(M, r= "", paletteinf = "", palettesup = "", titre = "", nom_axeX = "", nom_axeY = "", echelle = "Echelle"){
if (!is.vector(Z) & !is.matrix(Z) & !is.data.frame(Z)){stop("M must contain numbers")}
if(titre == ""){titre <- str_c("Var = " ,as.character(round(variance(M), 4)),  sep = "")}
else{titre <- str_c(titre, "  -  Var = " ,as.character(round(variance(M), 4)),  sep = "")}
M <- M |> long_shaped_matrix() # trois colonnes : les i, les j, les valeurs
p <- ggplot(data = M, aes(x = Var1 -0.5, y = Var2 - 0.5) )
if(r != ""){p <- ggplot(M, aes(x = Var1 -0.5+r , y = Var2 -0.5+r, z= value, fill=value))}
p <- p +
geom_tile(aes(fill = value))
if(paletteinf != "" & palettesup != ""){p <- p+scale_fill_viridis_c(option = "B", direction = -1, limits = c(paletteinf, palettesup))}
else{p <- p+scale_fill_viridis_c(option = "B", direction = -1)}
p <- p +
labs(title = titre,
x = nom_axeX,
y = nom_axeY) +
guides(fill = guide_colorbar(title = echelle))+
scale_y_continuous(breaks= scales::pretty_breaks())+
scale_x_continuous(breaks= scales::pretty_breaks())
return(p)
}
test_that("Anomaly test - error when M does not contain number", {
# arrange
Z <- "a"
# act & assert
expect_error(moving_average(Z, 2), "^M must contain numbers$")
})
#' @param nom_axeX name for X axis
#' @param nom_axeY name for Y axis
#' @param echelle title of scale
#'
#' @return a plot
#' @export
#'
#' @examples
#'
#' plot_matrix(matrix(rbinom(10*10, 1, 0.5), nrow = 10))
plot_matrix <- function(M, r= "", paletteinf = "", palettesup = "", titre = "", nom_axeX = "", nom_axeY = "", echelle = "Echelle"){
if (!is.vector(Z) & !is.matrix(Z) & !is.data.frame(Z)){stop("M must contain numbers")}
if(titre == ""){titre <- str_c("Var = " ,as.character(round(variance(M), 4)),  sep = "")}
else{titre <- str_c(titre, "  -  Var = " ,as.character(round(variance(M), 4)),  sep = "")}
M <- M |> long_shaped_matrix() # trois colonnes : les i, les j, les valeurs
p <- ggplot(data = M, aes(x = Var1 -0.5, y = Var2 - 0.5) )
if(r != ""){p <- ggplot(M, aes(x = Var1 -0.5+r , y = Var2 -0.5+r, z= value, fill=value))}
p <- p +
geom_tile(aes(fill = value))
if(paletteinf != "" & palettesup != ""){p <- p+scale_fill_viridis_c(option = "B", direction = -1, limits = c(paletteinf, palettesup))}
else{p <- p+scale_fill_viridis_c(option = "B", direction = -1)}
p <- p +
labs(title = titre,
x = nom_axeX,
y = nom_axeY) +
guides(fill = guide_colorbar(title = echelle))+
scale_y_continuous(breaks= scales::pretty_breaks())+
scale_x_continuous(breaks= scales::pretty_breaks())
return(p)
}
test_that("Anomaly test - error when M does not contain number", {
# arrange
Z <- "a"
# act & assert
expect_error(moving_average(Z, 2), "^M must contain numbers$")
})
library(ggplot2)
str_c <- stringr::str_c
#' @param nom_axeX name for X axis
#' @param nom_axeY name for Y axis
#' @param echelle title of scale
#'
#' @return a plot
#' @export
#'
#' @examples
#'
#' plot_matrix(matrix(rbinom(10*10, 1, 0.5), nrow = 10))
plot_matrix <- function(M, r= "", paletteinf = "", palettesup = "", titre = "", nom_axeX = "", nom_axeY = "", echelle = "Echelle"){
if (!is.vector(Z) & !is.matrix(Z) & !is.data.frame(Z)){stop("M must contain numbers")}
if(titre == ""){titre <- str_c("Var = " ,as.character(round(variance(M), 4)),  sep = "")}
else{titre <- str_c(titre, "  -  Var = " ,as.character(round(variance(M), 4)),  sep = "")}
M <- M |> long_shaped_matrix() # trois colonnes : les i, les j, les valeurs
p <- ggplot(data = M, aes(x = Var1 -0.5, y = Var2 - 0.5) )
if(r != ""){p <- ggplot(M, aes(x = Var1 -0.5+r , y = Var2 -0.5+r, z= value, fill=value))}
p <- p +
geom_tile(aes(fill = value))
if(paletteinf != "" & palettesup != ""){p <- p+scale_fill_viridis_c(option = "B", direction = -1, limits = c(paletteinf, palettesup))}
else{p <- p+scale_fill_viridis_c(option = "B", direction = -1)}
p <- p +
labs(title = titre,
x = nom_axeX,
y = nom_axeY) +
guides(fill = guide_colorbar(title = echelle))+
scale_y_continuous(breaks= scales::pretty_breaks())+
scale_x_continuous(breaks= scales::pretty_breaks())
return(p)
}
test_that("Anomaly test - error when M does not contain number", {
# arrange
Z <- "a"
# act & assert
expect_error(moving_average(Z, 2), "^M must contain numbers$")
})
load_all(p)
load_all()
test_that("Anomaly test - error when M does not contain number", {
# arrange
Z <- "a"
# act & assert
expect_error(moving_average(Z, 2), "^M must contain numbers$")
})
